//! 문제 설명
/*
    피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

    예를들어

    F(2) = F(0) + F(1) = 0 + 1 = 1
    F(3) = F(1) + F(2) = 1 + 1 = 2
    F(4) = F(2) + F(3) = 1 + 2 = 3
    F(5) = F(3) + F(4) = 2 + 3 = 5
    와 같이 이어집니다.

    2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.
*/

//! 제한 사항
//? 1. n은 1이상, 100000이하인 자연수입니다.

function solution(n) {
  //! n 번째 피보나치 수를 1234567 로 나누어야함
  //! F(n) = F(n - 1) + F(n - 2) 이다.

  //? 1. 문제의도
  /* 
    이 문제의 함정은 1234567 로 나눈 나머지의 값을 리턴해야 하는 것이다.
    굳이 왜 1234567 로 나누어야 하는가 하고 문제를 풀었다가 테스트 케이스 7번부터 아래까지 쭉 오답이었다.
    그러다가 정수의 범위(데이터 크기)에 대한 개념을 다시 떠올렸는데, 컴퓨터는 최대 정해진 정수의 범위(9007199254740991)가 있다.
    그래서 피보나치 수를 저장하는 반복의 과정에서 저 수의 범위를 넘으면 Infinity 와 같은 값으로 간주한다고 한다.
    위의 이유가 오류 발생의 이유였고, 간단하게 반복하는 과정에서 1234567 나머지 연산을 해주었다.
    전에는 미리 배열에 n 까지의 반복한 피보나치 수열의 값을 저장해두었었다.
  */

  //? 2. 시간복잡도
  //! 반복을 n 까지 하므로 O(n) 의 시간복잡도를 나타낸다.

  //? 3. 개선점
  //! 아직은 내 머리로는 개선점을 찾기 힘들어 다른 사람들의 코드를 참고하며 찾아보았지만
  //! 대부분이 반복을 n 까지 돌리거나, 재귀함수를 사용하여 이 문제를 풀었다. 그래서 개선점은 더 없을 것 같다.

  let arr = [0, 1];

  for (let i = 2; i <= n; i++) {
    arr.push((arr[i - 1] + arr[i - 2]) % 1234567);
  }

  return arr[n];
}

//! 입출력 예시
console.log(solution(3)); //* 결과: 2
console.log(solution(5)); //* 결과: 5
